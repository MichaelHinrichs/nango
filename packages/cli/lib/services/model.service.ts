import fs from 'node:fs';
import path from 'node:path';

import chalk from 'chalk';
import type { NangoModel, NangoModelField, NangoYamlParsed } from '@nangohq/types';
import type { ServiceResponse } from '@nangohq/shared';
import { NANGO_VERSION } from '@nangohq/shared';
import { getNangoRootPath, printDebug } from '../utils.js';
import { TYPES_FILE_NAME } from '../constants.js';
import { load } from './config.service.js';
import { shouldQuote } from '@nangohq/nango-yaml';

export type ModelsMap = Map<string, Record<string, any>>;

/**
 * Load nango.yaml and generate model.ts
 */
export function loadYamlAndGeneratedModel({ fullPath, debug = false }: { fullPath: string; debug?: boolean }): ServiceResponse<NangoYamlParsed> {
    if (debug) {
        printDebug(`Generating ${TYPES_FILE_NAME} file`);
    }

    const fp = path.resolve(fullPath, TYPES_FILE_NAME);
    if (!fs.existsSync(fp)) {
        if (debug) {
            printDebug('First compilation');
        }
    } else {
        if (debug) {
            printDebug(`File already exists, replacing`);
        }
    }

    const { success, error, response: parsed } = load(fullPath, debug);
    if (!success || !parsed) {
        console.log(chalk.red(error?.message));
        return { success: false, error: null, response: null };
    }

    const modelTs = buildModelsTS({ parsed });
    fs.writeFileSync(fp, modelTs);

    if (debug) {
        printDebug(`${TYPES_FILE_NAME} generated`);
    }

    return { success: true, error: null, response: parsed };
}

/**
 * Build models.ts
 */
export function buildModelsTS({ parsed }: { parsed: NangoYamlParsed }): string {
    const output: string[] = [
        '// ---------------------------',
        `// This file was generated by Nango (v${NANGO_VERSION})`,
        "// It's recommended to version this file",
        '// https://nango.dev',
        '// ---------------------------',
        ''
    ];

    output.push('// ------ Models');
    output.push(generateInterfaces({ parsed }).join('\n\n'));
    output.push('// ------ /Models');
    output.push('');

    output.push('// ------ SDK');
    output.push(generateSDKTypes({ parsed }));
    output.push('// ------ /SDK');
    output.push('');

    output.push(`// ------ Flows
export const NangoFlows = ${JSON.stringify(parsed.integrations, null, 2)} as const;
// ------ /Flows
`);

    return output.join('\n');
}

export function generateInterfaces({ parsed }: { parsed: NangoYamlParsed }): string[] {
    const interfaces: string[] = [];
    for (const [, model] of parsed.models) {
        interfaces.push(modelToTypescript({ model }));
    }

    return interfaces;
}

/**
 * Transform a JSON model to its Typescript equivalent
 */
export function modelToTypescript({ model }: { model: NangoModel }) {
    const output: string[] = [];
    if (model.isAnon) {
        output.push(`/** @deprecated It is recommended to use a Model */`);
        output.push(`export type ${model.name} = ${fieldToTypescript({ field: model.fields[0]! })}`);
    } else {
        output.push(`export interface ${model.name} {`);
        output.push(...fieldsToTypescript({ fields: model.fields }));
        output.push(`};`);
    }
    return output.join('\n');
}

export function fieldsToTypescript({ fields }: { fields: NangoModelField[] }) {
    const output: string[] = [];
    const dynamic = fields.find((field) => field.dynamic);

    // Insert dynamic key at the beginning
    if (dynamic) {
        if (!Array.isArray(dynamic.value)) {
            output.push(`  [key: string]: ${fieldToTypescript({ field: dynamic })};`);
        } else {
            output.push(`  [key: string]: {${fieldsToTypescript({ fields: dynamic.value }).join('\n')}};`);
        }
    }

    // Regular fields
    for (const field of fields) {
        if (field.dynamic) {
            continue;
        }

        output.push(`  ${shouldQuote(field.name) ? `"${field.name}"` : field.name}${field.optional ? '?' : ''}: ${fieldToTypescript({ field: field })};`);
    }

    return output;
}

/**
 * Transform a field definition to its typescript equivalent
 */
export function fieldToTypescript({ field }: { field: NangoModelField }): string | boolean | null | undefined | number {
    if (Array.isArray(field.value)) {
        if (field.union) {
            return field.value.map((f) => fieldToTypescript({ field: f })).join(' | ');
        }
        if (field.array) {
            return `(${field.value.map((f) => fieldToTypescript({ field: f })).join(' | ')})[]`;
        }

        return `{${fieldsToTypescript({ fields: field.value }).join('\n')}}`;
    }
    if (field.model || field.tsType) {
        return `${field.value}${field.array ? '[]' : ''}`;
    }
    if (field.value === null) {
        return 'null';
    }
    if (typeof field.value === 'string') {
        return `'${field.value}${field.array ? '[]' : ''}'`;
    }
    return `${field.value}${field.array ? '[]' : ''}`;
}

interface TmpInte {
    name: string;
    syncs: { input: string; output: Record<string, string> }[];
}
/**
 * Generate SDK types
 */
export function generateSDKTypes({ parsed }: { parsed: NangoYamlParsed }) {
    const typesContent = fs.readFileSync(`${getNangoRootPath()}/../shared/dist/sdk/sync.d.ts`, 'utf8');

    let syncModelsByName: string = '';
    const syncModelsByIntegration: TmpInte[] = [];
    const test: string[] = [];
    for (const integration of parsed.integrations) {
        const obj: TmpInte = {
            name: integration.providerConfigKey,
            syncs: []
        };
        test.push(`'${integration.providerConfigKey}': {`);
        for (const sync of integration.syncs) {
            test.push(`'${sync.name}': {`);
            const tmp: TmpInte['syncs'][0] = {
                input: 'never',
                output: {}
            };
            if (sync.input) {
                tmp['input'] = sync.input;
            }
            test.push(`input: ${sync.input || 'never'}`);
            if (sync.output) {
                test.push(`output: {`);
                for (const output of sync.output) {
                    const model = parsed.models.get(output);
                    if (!model || model.isAnon) {
                        continue;
                    }

                    syncModelsByName += `  '${model.name}': ${model.name};\n`;
                    tmp['output'][model.name] = model.name;
                    test.push(`${model.name}: ${model.name}`);
                }
                test.push(`}`);
            } else {
                test.push(`output: Record<string, never>`);
            }
            obj['syncs'].push(tmp);
            test.push(`}`);
        }
        test.push(`}`);

        syncModelsByIntegration.push(obj);
    }

    return `
${typesContent.replaceAll('NangoAction', 'NangoActionBase').replaceAll('NangoSync', 'NangoSyncBase')}
export type NangoAction = NangoActionBase;
export type NangoSync = NangoSyncBase<SyncModelsByName>;

export type SyncModelsByName = {
${syncModelsByName}
};
export type SyncModelsByIntegration = {
${test.join('\n')}
};
export type Sync = (nango: NangoSync)=> Promise<void>;
`;
}
